<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no" />
  <title>Biegacz Odliczający</title>
  <style>
    * { box-sizing: border-box; }
    html, body { margin: 0; padding: 0; height: 100%; background: #0f1115; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, sans-serif; color: #eee; }
    #app { position: relative; height: 100dvh; width: 100vw; overflow: hidden; }
    #gameCanvas { background: linear-gradient(180deg, #121622, #0b0d12); display: block; width: 100%; height: 100%; outline: none; }
    #gameCanvas:focus { outline: 2px solid #334155; outline-offset: -2px; }

    /* Top HUD */
    .hud { position: absolute; top: 0; left: 0; right: 0; display: flex; gap: 8px; padding: 10px 12px; align-items: center; justify-content: space-between; background: linear-gradient(180deg, rgba(0,0,0,0.55), rgba(0,0,0,0)); pointer-events: none; }
    .hud .left, .hud .center, .hud .right { display: flex; align-items: center; gap: 10px; }
    .badge { pointer-events: auto; padding: 6px 10px; border-radius: 12px; background: #1c2333; border: 1px solid #2a3248; font-weight: 600; font-size: 14px; }
    .muted { opacity: 0.85; font-weight: 500; }
    .nick { color: #7dd3fc; }
    .cta { pointer-events: auto; padding: 8px 12px; border-radius: 10px; border: 1px solid #334155; background: #0b1222; cursor: pointer; font-weight: 700; }
    .cta:active { transform: translateY(1px); }
    .link { pointer-events:auto; background:none; border:none; color:#93c5fd; text-decoration:underline; cursor:pointer; font-weight:700; }

    /* Bottom info bar */
    .bar { position: absolute; bottom: 0; left: 0; right: 0; padding: 10px 12px; display: flex; justify-content: space-between; align-items: center; background: linear-gradient(0deg, rgba(0,0,0,0.55), rgba(0,0,0,0)); }
    .small { font-size:12px; opacity:.8 }

    /* Modal */
    .modal-backdrop { position: absolute; inset: 0; background: rgba(0,0,0,0.6); display: none; align-items: center; justify-content: center; backdrop-filter: blur(2px); }
    .modal { width: min(92vw, 420px); background: #0f1629; border: 1px solid #2a385a; border-radius: 16px; padding: 18px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
    .modal h2 { margin: 0 0 10px; font-size: 18px; }
    .modal p { margin: 0 0 14px; color: #cbd5e1; }
    .modal .row { display: flex; gap: 10px; }
    .modal input { flex: 1; padding: 10px; border-radius: 10px; border: 1px solid #334155; background: #0b1222; color: #e5e7eb; }
    .modal .btn { padding: 10px 12px; border-radius: 10px; border: 1px solid #334155; background: #111a2e; color: #e5e7eb; cursor: pointer; font-weight: 700; }
    .modal .btn:disabled { opacity: 0.5; cursor: not-allowed; }

    /* Toast */
    .toast { position: absolute; left: 50%; transform: translateX(-50%); top: 64px; padding: 8px 12px; background: #0b1222; border: 1px solid #334155; border-radius: 999px; display: none; }

    /* Banner */
    .banner { position:absolute; left:50%; top:56px; transform: translateX(-50%); padding: 10px 14px; border-radius: 12px; font-weight: 800; font-size: clamp(14px,2.2vw,20px); letter-spacing:.2px; box-shadow: 0 6px 24px rgba(0,0,0,.35); pointer-events:none; text-align:center; }
    .banner.success { background: rgba(34,197,94,.12); border:1px solid rgba(34,197,94,.45); color:#86efac; }
    .banner.fail { background: rgba(239,68,68,.12); border:1px solid rgba(239,68,68,.45); color:#fecaca; }

    /* FX */
    .shake { animation: shake .2s linear 1; }
    @keyframes shake { 0%{ transform: translateX(0)} 25%{ transform: translateX(-3px)} 50%{ transform: translateX(3px)} 75%{ transform: translateX(-2px)} 100%{ transform: translateX(0)} }
  </style>
</head>
<body>
  <div id="app">
    <canvas id="gameCanvas" tabindex="0" aria-label="Bieg (fokus, aby działały klawisze)"></canvas>

    <div id="banner" class="banner success">Omijaj przeszkody – bonus <b>+1 pkt</b> w zasięgu!</div>

    <div class="hud">
      <div class="left">
        <div class="badge">Nick: <span id="nickLabel" class="nick">—</span></div>
        <div class="badge">Punkty na GrynaPlus: <span id="pointsCount">0</span></div>
        <div class="badge">Przeszkody (runda): <span id="obstaclesCount">0</span></div>
      </div>
      <div class="center">
        <div class="badge">Reklama za: <span id="countdown">02:00</span></div>
      </div>
      <div class="right">
        <button id="watchNow" class="cta" style="display:none">Obejrzyj reklamę</button>
        <button id="endGame" class="link">Zakończ grę</button>
      </div>
    </div>

    <div class="bar">
      <div class="muted">ℹ️ Standard: 1 reklama = <b>1 pkt<\/b> • Czysta runda = <b>2 pkt</b> na GrynaPlus • <span class="small">Chcesz zachować postęp obejrzanych reklam i nick? Obejrzyj reklamę przed wyjściem.</span> • <span class="small"><b>Bonus:</b> uniknij wszystkie przeszkody w rundzie (2:00) = +1 pkt</span></div>
      <div class="muted" id="statusMsg"></div>
    </div>

    <!-- Nick modal -->
    <div id="nickModal" class="modal-backdrop" style="display:flex">
      <div class="modal">
        <h2>Podaj swój nick</h2>
        <p>Nick będzie widoczny cały czas w grze.</p>
        <div class="row" style="margin-bottom:10px">
          <input id="nickInput" maxlength="24" placeholder="np. GrynaPlusFan" />
          <button id="saveNick" class="btn" disabled>Zapisz</button>
        </div>
        
      </div>
    </div>

    <!-- Checkpoint modal -->
    <div id="adModal" class="modal-backdrop">
      <div class="modal">
        <h2 id="adTitle">Checkpoint</h2>
        <p id="adText">Obejrzyj reklamę, aby odebrać <b>1 pkt</b> na GrynaPlus i biec dalej.</p>
        <div class="row">
          <button id="adBtn" class="btn">Oglądaj reklamę</button>
          <button id="laterBtn" class="btn" style="background:#1a233a">Później</button>
        </div>
        <p id="adError" style="display:none;color:#fca5a5;margin-top:10px">Reklama niedostępna. Spróbuj ponownie za chwilę.</p>
      </div>
    </div>

    <!-- End Game modal -->
    <div id="endModal" class="modal-backdrop">
      <div class="modal">
        <h2>Zakończyć grę?</h2>
        <p>Jeśli chcesz <b>zachować postęp obejrzanych reklam i nick</b> na serwerze, obejrzyj krótką reklamę przed wyjściem.</p>
        <div class="row">
          <button id="endAdBtn" class="btn">Obejrzyj reklamę i zapisz</button>
          <button id="quitBtn" class="btn" style="background:#1a233a">Wyjdź bez zapisu</button>
        </div>
        <p class="small" style="margin-top:10px">Uwaga: ta reklama nie nalicza punktu – służy wyłącznie do zapisu postępu.</p>
        <p id="endAdError" style="display:none;color:#fca5a5;margin-top:10px">Reklama niedostępna. Spróbuj ponownie za chwilę.</p>
      </div>
    </div>

    <div id="toast" class="toast"></div>
  </div>

  <script>
    // ======= Canvas setup =======
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    function resize() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.floor(canvas.clientWidth * dpr);
      canvas.height = Math.floor(canvas.clientHeight * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    const ro = new ResizeObserver(resize); ro.observe(canvas);

    // ======= State =======
    const state = {
      running: true,
      lastTime: 0,
      speed: 180,
      player: { x: 72, y: 200, w: 32, h: 32, inv: 0, dashCd: 0 },
      obstacles: [],
      nextObstacleIn: 0,
      countdown: 120000, // 2 min
      adsWatched: 0,
      points: 0,
      paused: false,
      roundHadHit: false,
      nick: localStorage.getItem('gp_nick') || '',
      lanes: 3,
      laneH: 0,
      // Continuous movement state
      keyDirY: 0,
      speedY: 0,
      baseSpeed: 240,
      fastSpeed: 520,
      accelTO: null,
      repeatIV: null,
      particles: [],
      world: { mode: 'clear', nextEventIn: 15000 },
      obstaclesThisRound: 0
    };

    // ======= UI elements =======
    const nickLabel = document.getElementById('nickLabel');
    const pointsCount = document.getElementById('pointsCount');
    const obstaclesCount = document.getElementById('obstaclesCount');
    const countdownLabel = document.getElementById('countdown');
    const watchNow = document.getElementById('watchNow');
    const statusMsg = document.getElementById('statusMsg');
    const endGame = document.getElementById('endGame');

    const nickModal = document.getElementById('nickModal');
    const nickInput = document.getElementById('nickInput');
    const saveNick = document.getElementById('saveNick');

    const adModal = document.getElementById('adModal');
    const adBtn = document.getElementById('adBtn');
    const laterBtn = document.getElementById('laterBtn');
    const adError = document.getElementById('adError');

    const endModal = document.getElementById('endModal');
    const endAdBtn = document.getElementById('endAdBtn');
    const quitBtn = document.getElementById('quitBtn');
    const endAdError = document.getElementById('endAdError');

    const toast = document.getElementById('toast');
    const banner = document.getElementById('banner');

    // ======= Utils =======
    function mmss(ms){
      const s = Math.max(0, Math.ceil(ms/1000));
      const m = Math.floor(s/60); const r = s % 60;
      return `${String(m).padStart(2,'0')}:${String(r).padStart(2,'0')}`;
    }
    function showToast(msg, ms=1600){
      toast.textContent = msg; toast.style.display='block';
      setTimeout(()=> toast.style.display='none', ms);
    }
    function setBanner(text, type='success'){
      banner.classList.remove('success','fail');
      banner.classList.add(type);
      banner.innerHTML = text;
      banner.style.display = 'block';
    }
    function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }
    function startLaneMove(dir){
      const old = state.currentLane;
      state.targetLane = Math.min(state.lanes-1, Math.max(0, state.currentLane + dir));
      if(state.targetLane === old){ return; }
      state.currentLane = state.targetLane;
      state.moveStartY = state.player.y;
      state.moveEndY = state.currentLane * state.laneH + (state.laneH - state.player.h)/2;
      state.moveAnimT = 0; // start animation
    }
    function setNick(n){
      state.nick = n.trim();
      localStorage.setItem('gp_nick', state.nick);
      nickLabel.textContent = state.nick || '—';
    }

    // ======= Nick modal logic =======
    function openNickModal(){ nickModal.style.display='flex'; }
    function closeNickModal(){
      nickModal.style.display='none';
      state._lastY = null; // reset swipe tracking
      try{ canvas.focus(); }catch(e){}
    }
    nickInput.addEventListener('input', ()=>{ saveNick.disabled = nickInput.value.trim().length < 3; });
    saveNick.addEventListener('click', ()=>{ setNick(nickInput.value); closeNickModal(); showToast('Nick zapisany'); });
    // Enter = kliknij "Zapisz"
    nickInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter' && !saveNick.disabled){ saveNick.click(); }});
    if(!state.nick){ openNickModal(); } else { setNick(state.nick); }

    // ======= World / obstacles =======
    function spawnObstacle(){
      const h = 40 + Math.random()*120;
      const lane = Math.floor(Math.random()*state.lanes);
      const y = lane * state.laneH + (state.laneH - h)/2;
      const speed = state.speed * (0.9 + Math.random()*0.2);
      const type = Math.random() < 0.4 ? 'moving' : 'static';
      state.obstacles.push({ x: canvas.clientWidth + 40, y, w: 24 + Math.random()*24, h, speed, type, dir: Math.random()<.5? -1:1 });
      // update round obstacle counter
      state.obstaclesThisRound += 1; obstaclesCount.textContent = String(state.obstaclesThisRound);
    }
    function worldEvents(dt){
      state.world.nextEventIn -= dt;
      if(state.world.nextEventIn <= 0){
        state.world.mode = (state.world.mode === 'clear') ? 'rain' : (state.world.mode==='rain'?'night':'clear');
        state.world.nextEventIn = 20000 + Math.random()*15000;
      }
    }

    // ======= Collision =======
    function collides(a,b){ return !(a.x+a.w < b.x || a.x > b.x+b.w || a.y+a.h < b.y || a.y > b.y+b.h); }
    function onHit(){
      state.roundHadHit = true;
      setBanner('Bonus stracony – powodzenia w następnej rundzie!','fail');
      showToast('Uwaga! Unikaj przeszkód');
      canvas.classList.add('shake'); setTimeout(()=> canvas.classList.remove('shake'), 200);
      state.player.inv = 550; // krótka nieśmiertelność
    }

    // ======= Input =======
    function moveToY(delta){
      state.player.y += delta;
    }
    function tryDash(){ if(state.player.dashCd<=0){ state.player.inv = 600; state.player.dashCd = 5000; showToast('Dash!'); } }

    window.addEventListener('keydown', (e)=>{
      if(['ArrowUp','ArrowDown','w','W','s','S',' '].includes(e.key) || e.code==='Space') e.preventDefault();
      const setDir = (dir)=>{
        state.keyDirY = dir;
        state.speedY = state.baseSpeed * dir;
        clearTimeout(state.accelTO); clearInterval(state.repeatIV);
        state.accelTO = setTimeout(()=>{ state.speedY = state.fastSpeed * dir; }, 200);
      };
      if(e.key === 'ArrowUp' || e.key === 'w' || e.key==='W') setDir(-1);
      if(e.key === 'ArrowDown' || e.key === 's' || e.key==='S') setDir(1);
      if(e.code === 'Space' || e.key===' ') tryDash();
    });
    window.addEventListener('keyup', (e)=>{
      if(['ArrowUp','ArrowDown','w','W','s','S'].includes(e.key)){
        if((e.key==='ArrowUp'||e.key==='w'||e.key==='W') && state.keyDirY<0) { state.keyDirY=0; state.speedY=0; }
        if((e.key==='ArrowDown'||e.key==='s'||e.key==='S') && state.keyDirY>0) { state.keyDirY=0; state.speedY=0; }
        clearTimeout(state.accelTO); clearInterval(state.repeatIV);
      }
    });

    let lastTap=0; canvas.addEventListener('touchstart', (e)=>{
      e.preventDefault();
      const now=Date.now();
      if(now - (window.__lastTap||0) < 280) { tryDash(); }
      window.__lastTap = now;
      state._lastY = e.touches[0].clientY;
    }, {passive:false});
    canvas.addEventListener('touchmove', (e)=>{
      e.preventDefault();
      const dy = e.touches[0].clientY - (state._lastY ?? e.touches[0].clientY);
      state._lastY = e.touches[0].clientY;
      moveToY(dy * 0.6);
    }, {passive:false});
    canvas.addEventListener('touchend', ()=>{ state._lastY = null; });

    // ======= Ads / countdown =======
    function updateCountdown(dt){
      if(state.countdown > 0){
        state.countdown -= dt;
        if(state.countdown <= 0){ state.countdown = 0; onCheckpointReady(); }
        countdownLabel.textContent = mmss(state.countdown);
        if(state.countdown < 11000 && !state._warned){ state._warned = true; statusMsg.textContent = 'Za chwilę dostępna reklama'; }
      }
    }
    function onCheckpointReady(){
      statusMsg.textContent = 'Reklama dostępna';
      state.paused = true; // zatrzymaj grę
      // dostosuj komunikat zależnie od czystej rundy
      const titleEl = document.getElementById('adTitle');
      const textEl = document.getElementById('adText');
      if(!state.roundHadHit){
        titleEl.textContent = 'Runda czysta!';
        textEl.innerHTML = 'Gratulacje, ominąłeś wszystkie przeszkody. Obejrzyj reklamę, aby zdobyć <b>2 pkt</b>.';
      } else {
        titleEl.textContent = 'Checkpoint';
        textEl.innerHTML = 'Obejrzyj reklamę, aby zdobyć <b>1 pkt</b> i biec dalej.';
      }
      // ukryj przycisk "Później" w checkpointcie (gra zatrzymana)
      laterBtn.style.display = 'none';
      openAdModal();
    }
    function resetCountdown(){
      state.countdown = 120000;
      state._warned = false;
      countdownLabel.textContent = mmss(state.countdown);
      statusMsg.textContent = '';
      watchNow.style.display = 'none';
      state.roundHadHit = false;
      state.obstaclesThisRound = 0; obstaclesCount.textContent = '0';
      setBanner('Omijaj przeszkody – bonus <b>+1 pkt</b> w zasięgu!','success');
      state.paused = false;
      laterBtn.style.display = '';
    }

    // ======= Monetag stubs (podmień SDK) =======
    async function showRewardedAd(){
      return new Promise((resolve, reject)=>{ const ok = Math.random() > 0.08; setTimeout(()=> ok?resolve():reject(new Error('Ad load error')), 2500); });
    }
    async function showSaveAd(){ // ad przy wyjściu (bez punktu)
      return new Promise((resolve, reject)=>{ const ok = Math.random() > 0.08; setTimeout(()=> ok?resolve():reject(new Error('Ad load error')), 2200); });
    }

    async function awardPoint(){ /* TODO: fetch('/api/gnp/award', {method:'POST', body: JSON.stringify({nick: state.nick})}) */ }
    async function awardBonusPoint(){ /* TODO: fetch('/api/gnp/awardBonus', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({nick: state.nick})}) */ }
    async function saveProgress(){ /* TODO: fetch('/api/gnp/save', {method:'POST', body: JSON.stringify({nick: state.nick, ads: state.adsWatched})}) */ }

    function openAdModal(){ adModal.style.display = 'flex'; adError.style.display='none'; }
    function closeAdModal(){ adModal.style.display = 'none'; }

    watchNow.addEventListener('click', ()=> openAdModal());
    laterBtn.addEventListener('click', ()=>{ closeAdModal(); });

    endGame.addEventListener('click', ()=>{ endModal.style.display='flex'; endAdError.style.display='none'; });

    adBtn.addEventListener('click', async ()=>{
      adBtn.disabled = true; adError.style.display='none';
      try {
        await showRewardedAd();
        // przyznaj punkty: 2 za czystą rundę, inaczej 1
        let gained = 1;
        await awardPoint();
        if(!state.roundHadHit){
          await awardBonusPoint();
          gained = 2;
        }
        state.points += gained; pointsCount.textContent = String(state.points);
        showToast(`+${gained} pkt przyznane`);
        resetCountdown();
        closeAdModal();
      } catch(err){ adError.style.display='block'; }
      finally { adBtn.disabled = false; }
    });

    endAdBtn.addEventListener('click', async ()=>{
      endAdBtn.disabled = true; endAdError.style.display='none';
      try {
        await showSaveAd();
        await saveProgress();
        showToast('Postęp zapisany');
        window.location.hash = '#exit';
      } catch(err){ endAdError.style.display='block'; }
      finally { endAdBtn.disabled = false; }
    });
    quitBtn.addEventListener('click', ()=>{ window.location.hash = '#exit'; });

    // ======= Game loop =======
    function update(dt){
      if(state.paused) return; // zatrzymanie gry na checkpointcie
      state.laneH = canvas.clientHeight / state.lanes;

      // Timers
      if(state.player.inv>0) state.player.inv -= dt;
      if(state.player.dashCd>0) state.player.dashCd -= dt;

      // Obstacles
      state.nextObstacleIn -= dt;
      if(state.nextObstacleIn <= 0){ spawnObstacle(); state.nextObstacleIn = 600 + Math.random()*600; }
      for(const o of state.obstacles){
        o.x -= (o.speed * dt/1000);
        if(o.type==='moving'){ o.y += o.dir * 60 * dt/1000; if(o.y < 0 || o.y + o.h > canvas.clientHeight){ o.dir *= -1; } }
      }
      state.obstacles = state.obstacles.filter(o => o.x + o.w > -20);

      // Collisions (ignore if invulnerable)
      if(state.player.inv<=0){ for(const o of state.obstacles){ if(collides(state.player, o)){ onHit(); break; } } }

      // Countdown + world events
      updateCountdown(dt);
      worldEvents(dt);

      // Continuous movement
      state.player.y += state.speedY * (dt/1000);
      // Clamp within screen
      state.player.y = Math.max(0, Math.min(canvas.clientHeight - state.player.h, state.player.y));
    }


    function draw(){
      const w = canvas.clientWidth, h = canvas.clientHeight;
      ctx.clearRect(0,0,w,h);

      // Background per world mode
      if(state.world.mode==='night'){
        ctx.fillStyle = '#0b0d12'; ctx.fillRect(0,0,w,h);
      } else if(state.world.mode==='rain'){
        ctx.fillStyle = '#0e1422'; ctx.fillRect(0,0,w,h);
        ctx.globalAlpha = 0.4; ctx.strokeStyle = '#1f2a44'; ctx.lineWidth = 1;
        for(let i=0;i<40;i++){ const x = (i*37 + (performance.now()/20)%w)%w; const y = (i*53 + (performance.now()/4)%h)%h; ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+2,y+10); ctx.stroke(); }
        ctx.globalAlpha = 1;
      } else {
        ctx.fillStyle = '#101522'; ctx.fillRect(0,0,w,h);
      }

      // Lane guides (subtle)
      ctx.globalAlpha = .06; ctx.fillStyle = '#ffffff';
      for(let i=1;i<state.lanes;i++){ ctx.fillRect(0, i*(h/state.lanes)-1, w, 2); }
      ctx.globalAlpha = 1;

      // Player
      ctx.fillStyle = state.player.inv>0 ? '#a5f3fc' : '#38bdf8';
      ctx.fillRect(state.player.x, state.player.y, state.player.w, state.player.h);

      // Obstacles
      ctx.fillStyle = '#8b5cf6';
      for(const o of state.obstacles){ ctx.fillRect(o.x, o.y, o.w, o.h); }
    }

    function loop(ts){
      if(!state.lastTime) state.lastTime = ts;
      const dt = Math.min(50, ts - state.lastTime); // cap dt
      state.lastTime = ts;
      update(dt); draw();
      requestAnimationFrame(loop);
    }

    // Initialize
    resize();
    // start roughly center vertically
    state.player.y = (canvas.clientHeight - state.player.h)/2;
    state.nextObstacleIn = 400;
    countdownLabel.textContent = mmss(state.countdown);
    pointsCount.textContent = String(state.points);

    // Info o bonusie na starcie (jednorazowo)
    setTimeout(()=>{ showToast('Uniknij wszystkich przeszkód = BONUS +1 pkt'); }, 600);

    // Focus canvas so key events work on macOS Safari/Chrome
    setTimeout(()=>{ try{ canvas.focus(); }catch(e){} }, 0);
    window.addEventListener('pointerdown', ()=>{ try{ canvas.focus(); }catch(e){} }, { once: true });

    requestAnimationFrame(loop);
  </script>
</body>
</html>
