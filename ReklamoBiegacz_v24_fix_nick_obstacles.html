<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, user-scalable=no" />
  <title>ReklamoBiegacz</title>

  <!-- Wklej tag Monetag SDK z panelu (jak w v23) -->
  <!-- <script>/* MONETAG TAG */</script> -->

  <style>
    * { box-sizing: border-box; }
    html, body { margin: 0; padding: 0; height: 100%; background: #0f1115; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, sans-serif; color: #eee; }
    #app { position: relative; height: 100dvh; width: 100vw; overflow: hidden; }
    #gameCanvas { background: linear-gradient(180deg, #121622, #0b0d12); display: block; width: 100%; height: 100%; outline: none; }
    #gameCanvas:focus { outline: 2px solid #334155; outline-offset: -2px; }

    .hud { position: absolute; top: 0; left: 0; right: 0; display: none; gap: 8px; padding: 10px 12px; align-items: center; justify-content: space-between; background: linear-gradient(180deg, rgba(0,0,0,0.55), rgba(0,0,0,0)); pointer-events: none; }
    .hud .left, .hud .center, .hud .right { display: flex; align-items: center; gap: 10px; }
    .badge { pointer-events: auto; padding: 6px 10px; border-radius: 12px; background: #1c2333; border: 1px solid #2a3248; font-weight: 600; font-size: 14px; }
    .muted { opacity: 0.85; font-weight: 500; }
    .nick { color: #7dd3fc; }
    .cta { pointer-events: auto; padding: 8px 12px; border-radius: 10px; border: 1px solid #334155; background: #0b1222; cursor: pointer; font-weight: 700; }
    .cta:active { transform: translateY(1px); }
    .link { pointer-events:auto; background:none; border:none; color:#93c5fd; text-decoration:underline; cursor:pointer; font-weight:700; }

    .bar { position: absolute; bottom: 0; left: 0; right: 0; padding: 10px 12px; display: none; justify-content: space-between; align-items: center; background: linear-gradient(0deg, rgba(0,0,0,0.55), rgba(0,0,0,0)); }
    .small { font-size:12px; opacity:.8 }

    .menu-backdrop { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background: radial-gradient(ellipse at center, rgba(13,18,34,0.95) 0%, rgba(9,12,22,0.98) 100%); }
    .menu { width:min(92vw,560px); padding:24px; border-radius:20px; border:1px solid #27334f; background:#0f1629; box-shadow:0 20px 60px rgba(0,0,0,.6); }
    .menu h1 { margin:4px 0 12px; font-size: clamp(28px, 5vw, 44px); letter-spacing:.6px; }
    .subtitle { margin:-6px 0 18px; color:#93c5fd; opacity:.9 }
    .row { display:flex; gap:10px; margin-top:8px; }
    .row input { flex:1; padding:12px; border-radius:12px; border:1px solid #334155; background:#0b1222; color:#e5e7eb; font-size:16px; }
    .btn { padding:12px 16px; border-radius:12px; border:1px solid #334155; background:#111a2e; color:#e5e7eb; font-weight:800; cursor:pointer; }
    .btn:disabled { opacity:.5; cursor:not-allowed; }
    .tips { margin-top:14px; color:#cbd5e1; font-size:14px; opacity:.9 }
    .brand { display:inline-block; padding:.2rem .6rem; border-radius:999px; border:1px solid #27334f; background:#0c1324; font-weight:800; letter-spacing:.2px; }

    .modal-backdrop { position: absolute; inset: 0; background: rgba(0,0,0,0.6); display: none; align-items: center; justify-content: center; backdrop-filter: blur(2px); }
    .modal { width: min(92vw, 420px); background: #0f1629; border: 1px solid #2a385a; border-radius: 16px; padding: 18px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
    .modal h2 { margin: 0 0 10px; font-size: 18px; }
    .modal p { margin: 0 0 14px; color: #cbd5e1; }
    .modal .row { display: flex; gap: 10px; }
    .modal .btn { padding: 10px 12px; border-radius: 10px; border: 1px solid #334155; background: #111a2e; color: #e5e7eb; cursor: pointer; font-weight: 700; }
    .modal .btn:disabled { opacity: 0.5; cursor: not-allowed; }

    .toast { position: absolute; left: 50%; transform: translateX(-50%); top: 64px; padding: 8px 12px; background: #0b1222; border: 1px solid #334155; border-radius: 999px; display: none; }
    .banner { position:absolute; left:50%; top:56px; transform: translateX(-50%); padding: 10px 14px; border-radius: 12px; font-weight: 800; font-size: clamp(14px,2.2vw,20px); letter-spacing:.2px; box-shadow: 0 6px 24px rgba(0,0,0,.35); pointer-events:none; text-align:center; display:none; }
    .banner.success { background: rgba(34,197,94,.12); border:1px solid rgba(34,197,94,.45); color:#86efac; }
    .banner.fail { background: rgba(239,68,68,.12); border:1px solid rgba(239,68,68,.45); color:#fecaca; }

    .shake { animation: shake .2s linear 1; }
    @keyframes shake { 0%{ transform: translateX(0)} 25%{ transform: translateX(-3px)} 50%{ transform: translateX(3px)} 75%{ transform: translateX(-2px)} 100%{ transform: translateX(0)} }
  </style>
</head>
<body>
  <div id="app">
    <canvas id="gameCanvas" tabindex="0" aria-label="Bieg (fokus, aby działały klawisze)"></canvas>

    <div id="banner" class="banner success">Omijaj przeszkody – bonus <b>+1 pkt</b> w zasięgu!</div>

    <div class="hud" id="hud">
      <div class="left">
        <div class="badge brand">ReklamoBiegacz</div>
        <div class="badge">Nick: <span id="nickLabel" class="nick">—</span></div>
        <div class="badge">Punkty na GrynaPlus: <span id="pointsCount">0</span></div>
        <div class="badge">Przeszkody (runda): <span id="obstaclesCount">0</span></div>
        <div class="badge">Poziom trudności: <span id="diffLabel">0</span></div>
      </div>
      <div class="center">
        <div class="badge">Reklama za: <span id="countdown">02:00</span></div>
      </div>
      <div class="right">
        <button id="watchNow" class="cta" style="display:none">Obejrzyj reklamę</button>
        <button id="endGame" class="link">Zakończ grę</button>
      </div>
    </div>

    <div class="bar" id="bbar">
      <div class="muted">ℹ️ Standard: 1 reklama = <b>1 pkt<\/b> • Czysta runda = <b>2 pkt</b> na GrynaPlus • <span class="small">Chcesz zachować postęp obejrzanych reklam i nick? Obejrzyj reklamę przed wyjściem.</span> • <span class="small"><b>Bonus:</b> uniknij wszystkie przeszkody w rundzie (2:00) = +1 pkt</span></div>
      <div class="muted" id="statusMsg"></div>
    </div>

    <!-- Start Menu -->
    <div id="startMenu" class="menu-backdrop">
      <div class="menu">
        <h1>ReklamoBiegacz</h1>
        <div class="subtitle">Wpisz swój nick i kliknij <b>Start</b>, aby rozpocząć bieg.</div>
        <div class="row">
          <input id="menuNick" maxlength="24" placeholder="np. GrynaPlusFan" />
          <button id="menuSave" class="btn" disabled>Zapisz</button>
          <button id="menuStart" class="btn" disabled>Start</button>
        </div>
        <div class="tips">Sterowanie: ↑/W i ↓/S (zmiana toru), Spacja (dash). Na telefonie: przeciągnij w górę/dół, dwuklik = dash.</div>
      </div>
    </div>

    <!-- Checkpoint modal -->
    <div id="adModal" class="modal-backdrop">
      <div class="modal">
        <h2 id="adTitle">Checkpoint</h2>
        <p id="adText">Obejrzyj reklamę, aby odebrać <b>1 pkt</b> na GrynaPlus i biec dalej.</p>
        <div class="row">
          <button id="adBtn" class="btn">Oglądaj reklamę</button>
          <button id="laterBtn" class="btn" style="background:#1a233a">Później</button>
        </div>
        <p id="adError" style="display:none;color:#fca5a5;margin-top:10px">Reklama niedostępna. Spróbuj ponownie za chwilę.</p>
      </div>
    </div>

    <!-- End Game modal -->
    <div id="endModal" class="modal-backdrop">
      <div class="modal">
        <h2>Zakończyć grę?</h2>
        <p>Jeśli chcesz <b>zachować postęp obejrzanych reklam i nick</b> na serwerze, obejrzyj krótką reklamę przed wyjściem.</p>
        <div class="row">
          <button id="endAdBtn" class="btn">Obejrzyj reklamę i zapisz</button>
          <button id="quitBtn" class="btn" style="background:#1a233a">Wyjdź bez zapisu</button>
        </div>
        <p class="small" style="margin-top:10px">Uwaga: ta reklama nie nalicza punktu – służy wyłącznie do zapisu postępu.</p>
        <p id="endAdError" style="display:none;color:#fca5a5;margin-top:10px">Reklama niedostępna. Spróbuj ponownie za chwilę.</p>
      </div>
    </div>

    <div id="toast" class="toast"></div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    function resize() {
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.floor(canvas.clientWidth * dpr);
      canvas.height = Math.floor(canvas.clientHeight * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    const ro = new ResizeObserver(resize); ro.observe(canvas);

    // ========= State =========
    const state = {
      started: false,
      running: true,
      lastTime: 0,
      speed: 170,
      player: { x: 76, y: 200, w: 28, h: 44, inv: 0, dashCd: 0 },
      obstacles: [],
      nextObstacleIn: 0,
      countdown: 120000,
      points: 0,
      paused: true,
      roundHadHit: false,
      nick: '',
      lanes: 3,
      laneH: 0,
      keyDirY: 0,
      speedY: 0,
      baseSpeed: 240,
      fastSpeed: 520,
      particles: [],
      world: { mode: 'clear', nextEventIn: 15000, t: 0, wind: 0 },
      obstaclesThisRound: 0,
      bg: { clouds: [], stars: [] },
      diff: { t:0, level:0 },
      debug: { hitboxes: false }
    };

    const hud = document.getElementById('hud');
    const bbar = document.getElementById('bbar');
    const nickLabel = document.getElementById('nickLabel');
    const pointsCount = document.getElementById('pointsCount');
    const obstaclesCount = document.getElementById('obstaclesCount');
    const countdownLabel = document.getElementById('countdown');
    const statusMsg = document.getElementById('statusMsg');
    const endGame = document.getElementById('endGame');
    const diffLabel = document.getElementById('diffLabel');

    const startMenu = document.getElementById('startMenu');
    const menuNick = document.getElementById('menuNick');
    const menuSave = document.getElementById('menuSave');
    const menuStart = document.getElementById('menuStart');

    const adModal = document.getElementById('adModal');
    const adBtn = document.getElementById('adBtn');
    const laterBtn = document.getElementById('laterBtn');
    const adError = document.getElementById('adError');

    const endModal = document.getElementById('endModal');
    const endAdBtn = document.getElementById('endAdBtn');
    const quitBtn = document.getElementById('quitBtn');
    const endAdError = document.getElementById('endAdError');

    const toast = document.getElementById('toast');
    const banner = document.getElementById('banner');

    // ========= Utils =========
    function mmss(ms){ const s=Math.max(0,Math.ceil(ms/1000)); const m=Math.floor(s/60); const r=s%60; return `${String(m).padStart(2,'0')}:${String(r).padStart(2,'0')}`; }
    function showToast(msg, ms=1600){ toast.textContent = msg; toast.style.display='block'; setTimeout(()=> toast.style.display='none', ms); }
    function setBanner(text, type='success'){ banner.classList.remove('success','fail'); banner.classList.add(type); banner.innerHTML=text; banner.style.display='block'; }
    function safeSetStorage(key,val){
      try{ localStorage.setItem(key,val); return true; } catch(e){ try{ sessionStorage.setItem(key,val); return true; } catch(_){ return false; } }
    }
    function safeGetStorage(key){
      try{ return localStorage.getItem(key) ?? sessionStorage.getItem(key) ?? ''; } catch(e){ try{ return sessionStorage.getItem(key) ?? ''; } catch(_){ return ''; } }
    }
    function setNick(n){
      state.nick = n.trim();
      const ok = safeSetStorage('gp_nick', state.nick);
      nickLabel.textContent = state.nick || '—';
      if(!ok){ showToast('Uwaga: pamięć przeglądarki zablokowana – nick zapisany tylko tymczasowo'); }
    }
    function validateNick(val){ return val.trim().length >= 3; }
    function rand(a,b){ return a + Math.random()*(b-a); }

    // Load saved nick (if any)
    const savedNick = safeGetStorage('gp_nick');
    if(savedNick){ state.nick = savedNick; menuNick.value = savedNick; menuSave.disabled = false; menuStart.disabled = false; nickLabel.textContent = savedNick; }

    // ========= Start menu / saving fixes =========
    menuNick.addEventListener('input', ()=>{
      const ok = validateNick(menuNick.value);
      menuSave.disabled = !ok; menuStart.disabled = !ok;
      if(ok){ setNick(menuNick.value); } // autosave na input
    });
    menuSave.addEventListener('click', ()=>{ if(!menuSave.disabled){ setNick(menuNick.value); showToast('Nick zapisany'); }});
    menuNick.addEventListener('keydown', (e)=>{ if(e.key==='Enter' && !menuStart.disabled){ menuStart.click(); }});
    menuStart.addEventListener('click', ()=>{
      if(menuStart.disabled) return;
      setNick(menuNick.value); // zapis przy starcie
      startMenu.style.display = 'none';
      hud.style.display = 'flex';
      bbar.style.display = 'flex';
      state.paused = false; state.started = true;
      setTimeout(()=>{ try{ canvas.focus(); }catch(e){} }, 0);
      setTimeout(()=>{ setBanner('Omijaj przeszkody – bonus <b>+1 pkt</b> w zasięgu!','success'); }, 500);
    });

    // ========= Obstacles =========
    function spawnObstacle(){
      const lane = Math.floor(Math.random()*state.lanes);
      const hLane = state.laneH;
      const type = Math.random()<0.5 ? 'crate' : 'cone';
      let w=36, h=36;
      if(type==='cone'){ w=30; h=46; }
      const y = lane*hLane + (hLane - h)/2;
      const speed = state.speed * (1.0 + Math.min(0.5, state.diff.level*0.01));
      // safety: don't spawn at identical Y as player to avoid instant unavoidable hit
      const minGap = 20;
      const avoid = Math.abs((state.player.y + state.player.h/2) - (y + h/2)) < (state.player.h/2 + h/2 + minGap);
      const finalY = avoid ? Math.max(0, Math.min(canvas.clientHeight - h, y + (y>state.player.y? minGap : -minGap))) : y;
      state.obstacles.push({ x: canvas.clientWidth + 60, y: finalY, w, h, speed, type });
      state.obstaclesThisRound += 1; obstaclesCount.textContent = String(state.obstaclesThisRound);
    }

    // Fair collisions (shrink 15%). Cones: even smaller inner box.
    function aabb(a,b){ return !(a.x+a.w < b.x || a.x > b.x+b.w || a.y+a.h < b.y || a.y > b.y+b.h); }
    function shrinkRect(r, f){ const dw = r.w*(1-f)/2, dh = r.h*(1-f)/2; return { x:r.x+dw, y:r.y+dh, w:r.w*(f), h:r.h*(f) }; }
    function collidesPlayerObstacle(p, o){
      const pf = shrinkRect({x:p.x,y:p.y,w:p.w,h:p.h}, 0.9);
      if(o.type==='cone'){
        const of = { x:o.x + o.w*0.2, y:o.y + o.h*0.05, w:o.w*0.6, h:o.h*0.9 };
        return aabb(pf, of);
      } else {
        const of = shrinkRect({x:o.x,y:o.y,w:o.w,h:o.h}, 0.85);
        return aabb(pf, of);
      }
    }

    function onHit(){
      state.roundHadHit = true;
      setBanner('Bonus stracony – powodzenia w następnej rundzie!','fail');
      showToast('Uwaga! Unikaj przeszkód');
      canvas.classList.add('shake'); setTimeout(()=> canvas.classList.remove('shake'), 200);
      state.player.inv = 550;
    }

    // ========= Input =========
    function tryDash(){ if(state.player.dashCd<=0){ state.player.inv = 600; state.player.dashCd = 5000; showToast('Dash!'); } }
    window.addEventListener('keydown', (e)=>{
      if(['ArrowUp','ArrowDown','w','W','s','S',' '].includes(e.key) || e.code==='Space') e.preventDefault();
      if(e.key==='h' || e.key==='H'){ state.debug.hitboxes = !state.debug.hitboxes; return; }
      if(state.paused) return;
      const setDir = (dir)=>{ state.keyDirY = dir; state.speedY = state.baseSpeed * dir; clearTimeout(state.accelTO); clearInterval(state.repeatIV); state.accelTO = setTimeout(()=>{ state.speedY = state.fastSpeed * dir; }, 200); };
      if(e.key === 'ArrowUp' || e.key === 'w' || e.key==='W') setDir(-1);
      if(e.key === 'ArrowDown' || e.key === 's' || e.key==='S') setDir(1);
      if(e.code === 'Space' || e.key===' ') tryDash();
    });
    window.addEventListener('keyup', (e)=>{
      if(['ArrowUp','ArrowDown','w','W','s','S'].includes(e.key)){
        if((e.key==='ArrowUp'||e.key==='w'||e.key==='W') && state.keyDirY<0) { state.keyDirY=0; state.speedY=0; }
        if((e.key==='ArrowDown'||e.key==='s'||e.key==='S') && state.keyDirY>0) { state.keyDirY=0; state.speedY=0; }
        clearTimeout(state.accelTO); clearInterval(state.repeatIV);
      }
    });

    // ========= Countdown / Ads (hook jak w v23) =========
    function updateCountdown(dt){
      if(!state.started) return;
      if(state.countdown > 0){
        state.countdown -= dt;
        if(state.countdown <= 0){ state.countdown = 0; onCheckpointReady(); }
        countdownLabel.textContent = mmss(state.countdown);
        if(state.countdown < 11000 && !state._warned){ state._warned = true; statusMsg.textContent = 'Za chwilę dostępna reklama'; }
      }
    }
    function onCheckpointReady(){
      statusMsg.textContent = 'Reklama dostępna';
      state.paused = true;
      const titleEl = document.getElementById('adTitle');
      const textEl = document.getElementById('adText');
      if(!state.roundHadHit){ titleEl.textContent = 'Runda czysta!'; textEl.innerHTML = 'Gratulacje, ominąłeś wszystkie przeszkody. Obejrzyj reklamę, aby zdobyć <b>2 pkt</b>.'; }
      else { titleEl.textContent = 'Checkpoint'; textEl.innerHTML = 'Obejrzyj reklamę, aby zdobyć <b>1 pkt</b> i biec dalej.'; }
      laterBtn.style.display = 'none';
      adModal.style.display = 'flex'; adError.style.display='none';
    }
    function resetCountdown(){
      state.countdown = 120000; state._warned = false; countdownLabel.textContent = mmss(state.countdown);
      statusMsg.textContent = ''; state.roundHadHit = false; state.obstaclesThisRound = 0; obstaclesCount.textContent = '0';
      setBanner('Omijaj przeszkody – bonus <b>+1 pkt</b> w zasięgu!','success'); state.paused = false; laterBtn.style.display = '';
    }

    // ========= Update / Draw =========
    function update(dt){
      if(state.paused) return;
      state.laneH = canvas.clientHeight / state.lanes;
      state.world.t += dt/1000; state.diff.t += dt;
      const lvl = Math.floor(state.diff.t/1000);
      if(lvl !== state.diff.level){ state.diff.level = lvl; diffLabel.textContent = String(lvl); state.speed = 170 + Math.min(180, lvl*1.5); }

      if(state.player.inv>0) state.player.inv -= dt;
      if(state.player.dashCd>0) state.player.dashCd -= dt;
      if(state.started) updateCountdown(dt);

      state.nextObstacleIn -= dt;
      if(state.nextObstacleIn <= 0){ spawnObstacle(); state.nextObstacleIn = 800 - Math.min(450, state.diff.level*5) + Math.random()*320; }
      for(const o of state.obstacles){ o.x -= (o.speed * dt/1000); }
      state.obstacles = state.obstacles.filter(o => o.x + o.w > -40);

      if(state.player.inv<=0){
        for(const o of state.obstacles){ if(collidesPlayerObstacle(state.player, o)){ onHit(); break; } }
      }

      state.player.y += state.speedY * (dt/1000);
      state.player.y = Math.max(0, Math.min(canvas.clientHeight - state.player.h, state.player.y));
    }

    function drawRunner(t){
      const p = state.player; const inv = state.player.inv>0;
      const bob = Math.sin(t*10) * 1.5; const x=p.x, y=p.y + bob;
      if(inv){ ctx.globalAlpha=0.25; ctx.fillStyle='#a5f3fc'; ctx.beginPath(); ctx.ellipse(x+10, y+p.h/2, 24, 18, 0, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }
      ctx.lineWidth=2; ctx.strokeStyle = inv ? '#a5f3fc' : '#38bdf8';
      ctx.beginPath(); ctx.arc(x+12, y+8, 6, 0, Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x+12, y+14); ctx.lineTo(x+12, y+30); ctx.stroke();
      const swing = Math.sin(t*12);
      ctx.beginPath(); ctx.moveTo(x+12, y+18); ctx.lineTo(x+12 + 8*swing, y+24); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x+12, y+18); ctx.lineTo(x+12 - 8*swing, y+24); ctx.stroke();
      const stride = Math.cos(t*12);
      ctx.beginPath(); ctx.moveTo(x+12, y+30); ctx.lineTo(x+12 + 10*stride, y+44); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x+12, y+30); ctx.lineTo(x+12 - 10*stride, y+44); ctx.stroke();
    }

    function drawBackground(){
      const w = canvas.clientWidth, h = canvas.clientHeight;
      // sky
      ctx.fillStyle = '#101522'; ctx.fillRect(0,0,w,h);

      // lane guides
      ctx.globalAlpha=.06; ctx.fillStyle='#ffffff'; for(let i=1;i<state.lanes;i++){ ctx.fillRect(0, i*(h/state.lanes)-1, w, 2); } ctx.globalAlpha=1;
    }

    function drawObstacles(){
      for(const o of state.obstacles){
        // fill
        if(o.type==='crate'){ ctx.fillStyle = '#8b5cf6'; }
        else if(o.type==='cone'){ ctx.fillStyle = '#f59e0b'; }
        ctx.fillRect(o.x, o.y, o.w, o.h);

        // halo/outline for visibility
        ctx.lineWidth = 3;
        ctx.strokeStyle = 'rgba(255,255,255,0.8)';
        ctx.strokeRect(o.x-1, o.y-1, o.w+2, o.h+2);

        // optional inner stroke for contrast
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'rgba(0,0,0,0.35)';
        ctx.strokeRect(o.x, o.y, o.w, o.h);

        if(state.debug.hitboxes){
          // show reduced hitbox used for collisions
          let hb;
          if(o.type==='cone'){ hb = { x:o.x + o.w*0.2, y:o.y + o.h*0.05, w:o.w*0.6, h:o.h*0.9 }; }
          else { hb = shrinkRect({x:o.x,y:o.y,w:o.w,h:o.h}, 0.85); }
          ctx.strokeStyle = '#22c55e'; ctx.lineWidth = 1.5;
          ctx.strokeRect(hb.x, hb.y, hb.w, hb.h);
        }
      }

      // player's hitbox in debug
      if(state.debug.hitboxes){
        const pf = shrinkRect({x:state.player.x,y:state.player.y,w:state.player.w,h:state.player.h}, 0.9);
        ctx.strokeStyle = '#60a5fa'; ctx.lineWidth = 1.5; ctx.strokeRect(pf.x, pf.y, pf.w, pf.h);
      }
    }

    function draw(){
      const w = canvas.clientWidth, h = canvas.clientHeight;
      ctx.clearRect(0,0,w,h);
      drawBackground();
      drawObstacles();
      drawRunner(state.world.t);
    }

    function loop(ts){
      if(!state.lastTime) state.lastTime = ts;
      const dt = Math.min(50, ts - state.lastTime);
      state.lastTime = ts;
      update(dt); draw();
      requestAnimationFrame(loop);
    }

    // Init
    resize();
    // restore player pos mid
    state.player.y = (canvas.clientHeight - state.player.h)/2;
    state.nextObstacleIn = 400;
    countdownLabel.textContent = mmss(state.countdown);
    pointsCount.textContent = String(state.points);
    setTimeout(()=>{ try{ canvas.focus(); }catch(e){} }, 0);
    window.addEventListener('pointerdown', ()=>{ try{ canvas.focus(); }catch(e){} }, { once: true });
    requestAnimationFrame(loop);
  </script>
</body>
</html>
